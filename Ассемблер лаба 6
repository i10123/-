КОД КОТОРЫЙ НАДО ПЕРЕДЕЛАТЬ
masm
.model small
.386
.stack 128

.data
    sign db ?
    X dw ?
    Y dw ?
    F dw ?
    msgX db 'Input X: $'
    msgY db 'Input Y: $'
    error_msg db 'Error number!', 10, 13, '$'
    msgFormula db 'F = (Y * 32) % X / 22', 10, 13, '$'
    msgResult db 'Result: $'
    msgChet db 10, 13,'Chetnoe', 10, 13, '$'
    msgNechet db 10, 13,'Nechetnoe', 10, 13, '$'
    msgPositive db 'Positive$'
    msgNegative db 'Negative$'

.code
InputNumber proc
    jmp input_start
input_error:
    mov dx, offset error_msg
    mov ah, 09h
    int 21h
    ret
input_start:
    xor bx, bx
    mov sign, 0
    mov ah, 01h
    int 21h
    cmp al, '-'
    jne check_first_num
    mov sign, 1
    mov ah, 01h
    int 21h
check_first_num:
    cmp al, '0'
    jb input_error
    cmp al, '9'
    ja input_error
coninput:
    sub al, 30h
    mov bl, al
    mov dx, 10
Input:
    mov ah, 01h
    int 21h
    cmp al, 0Dh
    je EndPrint
    cmp al, '0'
    jb input_error
    cmp al, '9'
    ja input_error
    sub al, 30h
    mov cl, al
    mov ax, bx
    imul dx
    add ax, cx
    mov bx, ax
    cbw
    jmp Input
EndPrint:
    cmp sign, 1
    jne check_positive
    cmp bx, 32768
    ja input_error
    neg bx
    jmp final
check_positive:
    cmp bx, 32767
    ja input_error
final:
    mov cx, bx
    ret
InputNumber endp

OutputNumber proc
    cmp ax, 0
    jns Positive
    push ax
    mov dl, '-'
    mov ah, 02h
    int 21h
    pop ax
    neg ax
Positive:
    mov bx, 10
    xor cx, cx
ConvertLoop:
    xor dx, dx
    div bx
    push dx
    inc cx
    cmp ax, 0
    jnz ConvertLoop
PrintLoop:
    pop dx
    cmp dx, 10
    je exit
    add dl, '0'
    mov ah, 02h
    int 21h
    loop PrintLoop
    ret
OutputNumber endp

start:
    mov ax, @data
    mov ds, ax
    
    mov dx, offset msgFormula
    mov ah, 09h
    int 21h
Input_Y:
    mov dx, offset msgY
    mov ah, 09h
    int 21h
    call InputNumber
    mov Y, cx
Input_X:
    mov dx, offset msgX
    mov ah, 09h
    int 21h
    call InputNumber
    mov X, cx
    cmp cx, 0
    jne Primer
    mov dx, offset error_msg
    mov ah, 09h
    int 21h
    jmp Input_X 
Primer: 
    mov ax, Y
    shl ax, 5
    cwd
    idiv X  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov ax, dx    
    shr ax, 4
    mov cx, ax
    shr ax, 5
    sub cx, ax
    shr ax, 6
    add ax, cx
    mov F, ax
    
Print_res:
    mov dx, offset msgResult
    mov ah, 09h
    int 21h
    mov ax, F
    call OutputNumber    
Check_parity:
    shr F, 1  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; log comand
    jnc PrintChet
    mov dl, offset msgNechet
    jmp PrintMessage
PrintChet:
    mov dl, offset msgChet
PrintMessage:
    mov ah, 09h
    int 21h

    cmp sign, 1   ;;;;;;;;;;;;;;;;;;; log comand
    je PrintNegative
    mov dx, offset msgPositive
    jmp PrintMessageEnd
PrintNegative:
    mov dx, offset msgNegative
PrintMessageEnd:
    mov ah, 09h
    int 21h
Exit:
    mov ax, 4C00h
    int 21h
end start

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
masm 
model small 
.386
.stack 400h 
.data
    x dw ?
    y dw ?
    Ost dw ?
    F db 'F = (Y * 32) % X / 22', 10, 13, '$'
    Answer dw ?
    newline db 13,10,'$'
    Border db '-------------------$'
    Output1 db '4etnoe$'
    Output2 db 'Ne4etnoe$'
    OutPositive db 'Positive$'
    OutNegative db 'Negative$'
    sign db ?
    count db ?
.code
start:
    mov ax,@data
    mov ds, ax
 
InputY:    
    mov ah, 09h
    mov dx, offset F
    int 21h
    mov ah, 09h
    mov dx, offset newline
    int 21h

    mov sign, 0 
    mov ah, 01h 
    int 21h 
    cmp al, '-' 
    jne coninput1 
    mov sign, 1 
    mov ah, 01h 
    int 21h
    
    coninput1:                                                     
        sub al, 30h                                                                                                                                                                                                                                                                                                                      
        mov ah, 0 
        mov bx, 10 
        mov cx, ax 
    
    FirstInput1: 
        mov ah, 01h 
        int 21h 
        cmp al, 0dh 
        je EndFirst1 
        sub al, 30h 
        cbw 
        xchg ax,cx 
        mul bx 
        add cx,ax 
        jmp FirstInput1
    
        EndFirst1: 
            cmp sign, 1 
            jne FinA
            neg cx
    
        FinA:
            mov y, cx
 
    InputX:    
        mov sign, 0 
        mov ah, 01h 
        int 21h 
        cmp al, '-' 
        jne coninput2 
        mov sign, 1 
        mov ah, 01h 
        int 21h
    
        coninput2:                                                     
            sub al, 30h                                                                                                                                                                                                                                                                                                                      
            mov ah, 0 
            mov bx, 10 
            mov cx, ax 
    
        FirstInput2: 
            mov ah, 01h 
            int 21h 
            cmp al, 0dh 
            je EndFirst2 
            sub al, 30h 
            cbw 
            xchg ax,cx 
            mul bx 
            add cx,ax 
            jmp FirstInput2
    
        EndFirst2: 
            cmp sign, 1 
            jne FinB
            neg cx
    
        FinB:
            mov x, cx
 
    Primer:
        ; Y * 32
        mov bx, 1
        sal y, 5
        mov ax, y
        imul bx
        ; (Y * 32) % X
        mov cx, ax
        mov bx, x
        idiv bx
        imul bx
        cmp cx, 0
        jg Positive1
        neg cx
        neg ax
        
        Negative1:
            cmp bx, 0
            jg Positive_Negative
            jmp Two_Positives

        Positive1:
            cmp bx, 0
            jg Two_Positives

        Positive_Negative:
            sub cx, ax
            neg cx
            mov count, 1
            jmp EndAnswer
            
        Two_Positives:
            sub cx, ax
        ; (Y * 32) % X / 22
        EndAnswer:
            mov Ost, cx
            mov bx, 11
            sal bx, 1
            mov ax, Ost
            idiv bx
            mov Answer,ax
        
    ChekZero:
        mov bl, 00000001b
        and al, 00000001b
        and bl, al
        cmp bl, 1
        je OutputNe4et
        jmp Output4et
        
    OutputNe4et:
        mov ah, 09h
        mov dx, offset newline
        int 21h
        mov ah, 09h
        mov dx, offset Output2
        int 21h
        jmp ChekSign
        
    Output4et:
        mov ah, 09h
        mov dx, offset newline
        int 21h
        mov ah, 09h
        mov dx, offset Output1
        int 21h
        
    ChekSign:
        cmp count, 1
        je NegativeSign
        jmp PositiveSign
        
    NegativeSign:
        mov ah,09h
        mov dx,offset newline
        int 21h
        mov ah,09h
        mov dx,offset OutNegative
        int 21h
        jmp OutputF
        
    PositiveSign:
        mov ah,09h
        mov dx,offset newline
        int 21h
        mov ah,09h
        mov dx,offset OutPositive
        int 21h
        
    OutputF:
        mov ah,09h
        mov dx,offset Border
        int 21h
        mov ah,09h
        mov dx,offset newline
        int 21h
        xor dx, dx
        push -1
        mov ax, Answer
        cmp ax, 0
        jnl contX
        mov cx, ax
        mov ah, 02h
        mov dl, '-'
        int 21h
        mov ax, cx
        neg ax
 
        contX:
            mov bx, 10
 
        contX2:
            mov dx, 0
            div bx
            push dx
            cmp ax, 0
            jne contX2
 
        OutX:
            pop dx
            cmp dx, -1
            je Exit
            add dl, 30h
            mov ah, 02h
            int 21h
            jmp OutX
  
    Exit: 
        mov ax,4c00h 
        int 21h 
end start
