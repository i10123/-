#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <ctime>
#include <conio.h>
#include <windows.h>
#include <cmath>
#include <iomanip>
#include <map>
#include <algorithm>

using namespace std;

const string GREEN = "\033[32m";
const string RED = "\033[31m";
const string YELLOW = "\033[33m";
const string PURPLE = "\033[35m";
const string BLUE = "\033[36m";
const string RESET = "\033[0m";
const string B = "\033[1m";

// функция для очистки консоли
static void clearConsole() {
#ifdef _WIN32
    system("cls");
#endif
}
// функция для обработки ошибок
static int input_check_int(const string& message, int min, int max) {
    int input;

    while (true) {
        cout << message;
        cin >> input;

        if (cin.fail() || floor(input) != input) {
            cin.clear();
            cin.ignore(INT_MAX, '\n');
            cout << "Ошибка ввода! Пожалуйста, введите число от " << min << " до " << max << endl;
            continue;
        }

        if (input < min || input > max) {
            cout << "Ошибка ввода! Пожалуйста, введите число от " << min << " до " << max << endl;
            cin.ignore(INT_MAX, '\n');
            continue;
        }

        cin.ignore(INT_MAX, '\n');
        return input;
    }
}
static double input_check_double(const string& message, double min, double max) {
    double input;

    while (true) {
        cout << message;
        cin >> input;

        if (cin.fail()) {
            cin.clear();
            cin.ignore(INT_MAX, '\n');
            cout << "Ошибка ввода! Введите число от " << fixed << setprecision(2) << min << " до " << max << endl;
            continue;
        }

        if (input < min || input > max) {
            cout << "Ошибка! Значение должно быть от " << fixed << setprecision(2) << min << " до " << max << endl;
            cin.ignore(INT_MAX, '\n');
            continue;
        }

        cin.ignore(INT_MAX, '\n');

        return round(input * 100) / 100;
    }
}
static bool checkDateFormat(const string& date) {
    if (date.size() != 10 || date[2] != '.' || date[5] != '.') return false;

    string dayStr = date.substr(0, 2);
    string monthStr = date.substr(3, 2);
    string yearStr = date.substr(6, 4);

    for (char c : dayStr + monthStr + yearStr)
        if (!isdigit(c)) return false;

    int day = stoi(dayStr);
    int month = stoi(monthStr);
    int year = stoi(yearStr);

    if (month < 1 || month > 12 || year < 1900 || year > 2100) return false;
    int daysInMonth[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    if (month == 2 && (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)))
        daysInMonth[1] = 29;

    return day >= 1 && day <= daysInMonth[month - 1];
}

// вступление
static void showWelcomeScreen() {
    clearConsole();

    cout << GREEN << B << "***************************************************************************\n";
    cout << "*                          УЧЁТ ДОМАШНИХ ФИНАНСОВ                         *\n";
    cout << "***************************************************************************\n\n" << RESET;
    cout << GREEN << "Добро пожаловать! Это приложение поможет вам вести учет доходов и расходов.\n";
    cout << "Вы можете добавлять транзакции, сортировать их и просматривать статистику.\033[0m\n\n";
    cout << BLUE << "Нажмите " << GREEN << "Enter" << BLUE << ", чтобы продолжить или " 
        << RED << "Esc " << BLUE << "для выхода..." << RESET;

    while (true) {
        char key = _getch();
        if (key == 27) exit(0); // Esc
        if (key == 13) break;   // Enter
    }
}
// получение текущей даты и времени
static string getNowDateTime() {
    time_t now = time(0);
    tm localTime;
    localtime_s(&localTime, &now);

    stringstream ss;
    ss << (localTime.tm_mday < 10 ? "0" : "") << localTime.tm_mday << "."
        << ((localTime.tm_mon + 1) < 10 ? "0" : "") << (localTime.tm_mon + 1) << "."
        << (localTime.tm_year + 1900) << " "
        << (localTime.tm_hour < 10 ? "0" : "") << localTime.tm_hour << ":"
        << (localTime.tm_min < 10 ? "0" : "") << localTime.tm_min;

    return ss.str();
}
struct Transaction {
    string dateTime;        // Дата и Время
    string userName;        // Имя пользователя
    string type;            // "Доход" или "Расход"
    double summa;           // Сумма
    string paymentMethod;   // "Карта" или "Наличные"
    string category;        // Категория
    string storeName;       // Название магазина
    string comment;         // Комментарий

    Transaction()
        : dateTime(""), userName(""), type(""), summa(0), paymentMethod(""), category(""), storeName(""), comment("") {}
    
    Transaction(string user, string t, double sum, string payment, string cat, string store, string com)
        : userName(user), type(t), summa(sum), paymentMethod(payment), category(cat), storeName(store), comment(com) {
        dateTime = getNowDateTime(); // Формат: ДД.ММ.ГГГГ ЧЧ:ММ
    }

    string toTXT() const {
        stringstream ss;
        ss << dateTime << "," << userName << "," << type << "," << summa << "," << paymentMethod;
        if (type == "расход") { ss << "," << category << "," << storeName; }
        ss << "," << comment;
        return ss.str();
    }
};
struct Balance {
    double totalSumma;              // Общая сумма (нал + карты)
    double cash;                    // Наличные
    double card;                    // Все карты
    double monthExpenses;           // Сумма всех трат за месяц
    double averageDayExpense;       // Средняя трата за день
    double averageMonthExpense;     // Средняя трата за месяц

    Balance() {
        totalSumma = 0.0;
        cash = 0.0;
        card = 0.0;
        monthExpenses = 0.0;
        averageDayExpense = 0.0;
        averageMonthExpense = 0.0;
        loadFromFile();
    }

    void saveToFile() const {
        ofstream file("balance.txt");
        if (file.is_open()) {
            file << totalSumma << "\n"
                << cash << "\n"
                << card << "\n"
                << monthExpenses << "\n"
                << averageDayExpense << "\n"
                << averageMonthExpense << "\n";
            file.close();
        }
        else {
            cerr << "Ошибка сохранения данных в файл!\n";
        }
    }

    void loadFromFile() {
        ifstream file("balance.txt");
        if (file.is_open()) {
            file >> totalSumma;
            file >> cash;
            file >> card;
            file >> monthExpenses;
            file >> averageDayExpense;
            file >> averageMonthExpense;
            file.close();
        }
        else {
            cerr << "Ошибка загрузки данных!\n";
        }
    }
};

class MoneyManager {
private:
    Balance userBalance;
    vector<Transaction> transactions;

public:
    // 1. БАЛАНС
    void Balance() {
        clearConsole();
        loadTransactions();
        userBalance.loadFromFile();

        double totalBalance = userBalance.cash + userBalance.card;
        double monthExpenses = getMonthExpenses(transactions, getNowMonth(), getNowYear());
        userBalance.averageDayExpense = getAverageDayExpense(transactions);
        userBalance.averageMonthExpense = getAverageMonthExpense(transactions);
        userBalance.saveToFile();

        cout << B << PURPLE << "         **ФИНАНСОВЫЙ ОТЧЕТ**\n";
        cout << "--------------------------------------\n";
        cout << setw(26) << left << "Общий баланс: " << fixed << setprecision(2) << totalBalance << " BYN\n";
        cout << "--------------------------------------\n";
        cout << setw(26) << left << "Наличные: " << userBalance.cash << " BYN\n";
        cout << "--------------------------------------\n";
        cout << setw(26) << left << "На картах: " << userBalance.card << " BYN\n";
        cout << "--------------------------------------\n";
        cout << setw(26) << left << setw(26) << left << "Сумма расходов за месяц: " << monthExpenses << " BYN\n";
        cout << "--------------------------------------\n";
        cout << setw(26) << left << "Средний расход в день: " << userBalance.averageDayExpense << " BYN\n";
        cout << "--------------------------------------\n";
        cout << setw(26) << left << "Средний расход в месяц: " << userBalance.averageMonthExpense << " BYN\n";
        cout << "--------------------------------------\n" << RESET;
    }
    // 2. ДОБАВИТЬ ТРАНЗАКЦИЮ
    void addTransaction() {
        clearConsole();
        string userName, type, paymentMethod = "", category = "", storeName = "", comment = "";
        double summa = 0.0;
        int paymentChoice, choice;
        do {
            cout << B << "Введите своё имя: ";
            char choice = _getch();
            if (choice == 27) {
                cout << B << endl;
                return;
            }
            getline(cin, userName);
            if (userName.empty()) {
                cout << "Ошибка! Имя не может быть пустым.\n";
            }
        } while (userName.empty());

        choice = input_check_int("Выберите тип операции (1 - Доход, 2 - Расход): ", 1, 2);

        switch (choice) {
        case 1:
            type = "доход";
            summa = input_check_double("Введите сумму: ", 0, 1000000000);
            paymentChoice = input_check_int("Выберите способ оплаты (1 - Карта, 2 - Наличные): ", 1, 2);
            paymentMethod = (paymentChoice == 1) ? "карта" : "наличные";
            cout << "Введите комментарий (по желанию): ";
            getline(cin, comment);

            if (paymentMethod == "наличные") {
                userBalance.cash += summa;
            }
            else {
                userBalance.card += summa;
            }
            break;

        case 2:
            type = "расход";
            summa = input_check_double("Введите сумму: ", 0, 1000000000);
            paymentChoice = input_check_int("Выберите способ оплаты (1 - Карта, 2 - Наличные): ", 1, 2);
            paymentMethod = (paymentChoice == 1) ? "карта" : "наличные";
            cout << "Введите категорию расхода: ";
            getline(cin, category);
            cout << "Введите название магазина: ";
            getline(cin, storeName);
            cout << "Введите комментарий (по желанию): ";
            getline(cin, comment);

            userBalance.monthExpenses += summa;

            if (paymentMethod == "наличные") {
                userBalance.cash -= summa;
            }
            else {
                userBalance.card -= summa;
            }
            break;

        default:
            cout << "\nНекорректный выбор!\n";
            return;
        }

        Transaction newTransaction(userName, type, summa, paymentMethod, category, storeName, comment);
        transactions.push_back(newTransaction);

        userBalance.totalSumma = userBalance.cash + userBalance.card;
        userBalance.saveToFile();  // 📌 **Сохранение баланса**
        saveTransactions();        // 📌 **Сохранение транзакций**

        cout << "\nТранзакция успешно добавлена!\n";
    }
    // 3. РЕДАКТИРОВАТЬ ТРАНЗАКЦИЮ
    void redactTransaction() {
        loadTransactions();
        clearConsole();

        if (transactions.empty()) {
            cout << B << "Нет транзакций для редактирования!\n";
            return;
        }

        string Date;

        while (true) {
            cout << B << YELLOW << "ДЛЯ РЕДАКТИРОВАНИЯ\n" << RESET;
            cout << B << "Введите дату транзакции(ДД.ММ.ГГГГ) : ";
            char choice = _getch(); // тут баг с повторным вводом первого символа
            if (choice == 27) {
                cout << endl;
                return;
            }
            getline(cin, Date);
            if (checkDateFormat(Date)) break;
            else clearConsole();
        }

        vector<Transaction*> listTransactions = searchTransByDate(Date);

        if (listTransactions.empty()) {
            cout << "Нет транзакций на эту дату!\n";
            return;
        }

        cout << "Транзакции за " << Date << ":\n\n";
        cout << setw(5) << left << "№"
            << setw(8) << left << "Тип"
            << setw(20) << left << "Дата и время"
            << setw(15) << left << "Пользователь"
            << setw(15) << left << "Категория"
            << setw(15) << left << "Магазин"
            << setw(15) << left << "Сумма (BYN)"
            << setw(15) << left << "Оплата"
            << setw(20) << left << "Комментарий" << endl;

        cout << string(120, '-') << endl;

        for (size_t i = 0; i < listTransactions.size(); i++) {
            cout << setw(5) << left << i + 1
                << setw(8) << left << listTransactions[i]->type
                << setw(20) << left << listTransactions[i]->dateTime
                << setw(15) << left << listTransactions[i]->userName
                << setw(15) << left << (listTransactions[i]->type == "расход" ? listTransactions[i]->category : "-")
                << setw(15) << left << (listTransactions[i]->type == "расход" ? listTransactions[i]->storeName : "-")
                << setw(15) << left << fixed << setprecision(2) << listTransactions[i]->summa
                << setw(15) << left << listTransactions[i]->paymentMethod
                << setw(20) << left << listTransactions[i]->comment << endl;
        }
        cout << endl;
        int index = input_check_int("Введите номер транзакции для редактирования: ", 1, listTransactions.size()) - 1;

        while (true) {
            clearConsole();

            cout << "Редактирование транзакции:\n";
            cout << setw(15) << left << "Дата:" << listTransactions[index]->dateTime << endl;
            cout << setw(15) << left << "Пользователь:" << listTransactions[index]->userName << endl;
            cout << setw(15) << left << "Тип:" << listTransactions[index]->type << endl;
            cout << setw(15) << left << "Сумма (BYN):" << fixed << setprecision(2) << listTransactions[index]->summa << endl;
            cout << setw(15) << left << "Категория:" << listTransactions[index]->category << endl;
            cout << setw(15) << left << "Магазин:" << listTransactions[index]->storeName << endl;
            cout << setw(15) << left << "Оплата:" << listTransactions[index]->paymentMethod << endl;
            cout << setw(15) << left << "Комментарий:" << listTransactions[index]->comment << endl;
            cout << string(50, '-') << endl;

            cout << "Выберите действие:\n";
            cout << "1. Изменить имя пользователя\n";
            cout << "2. Изменить тип транзакции (Доход/Расход)\n";
            cout << "3. Изменить сумму\n";
            cout << "4. Изменить категорию (только для расходов)\n";
            cout << "5. Изменить магазин (только для расходов)\n";
            cout << "6. Изменить способ оплаты\n";
            cout << "7. Изменить комментарий\n";
            cout << "8. Сохранить изменения\n";
            cout << "9. Отменить изменения\n";

            int choice = input_check_int("\nВведите номер: ", 1, 9);
            
            int newType, newType2;
            switch (choice) {
            case 1:
                cout << "Введите новое имя пользователя: ";
                getline(cin, listTransactions[index]->userName);
                break;
            case 2: {
                cout << "Выберите новый тип транзакции (1 - Доход, 2 - Расход): ";
                newType = input_check_int("", 1, 2);
                listTransactions[index]->type = (newType == 1) ? "доход" : "расход";

                if (newType == 2) {
                    cout << "Введите категорию расхода: ";
                    getline(cin, listTransactions[index]->category);
                    cout << "Введите название магазина: ";
                    getline(cin, listTransactions[index]->storeName);
                }
                else {
                    listTransactions[index]->category = "-";
                    listTransactions[index]->storeName = "-";
                }
                break;
            }
            case 3:
                listTransactions[index]->summa = input_check_double("Введите новую сумму: ", 0, 1000000000);
                break;
            case 4:
                if (listTransactions[index]->type == "расход") {
                    cout << "Введите новую категорию: ";
                    getline(cin, listTransactions[index]->category);
                }
                break;
            case 5:
                if (listTransactions[index]->type == "расход") {
                    cout << "Введите новый магазин: ";
                    getline(cin, listTransactions[index]->storeName);
                }
                break;
            case 6:
                cout << "Введите новый способ оплаты (1 - наличные, 2 - карта): ";
                newType2 = input_check_int("", 1, 2);
                listTransactions[index]->paymentMethod = (newType2 == 1) ? "наличные" : "карта";

                for (auto& t : transactions) {
                    if (t.dateTime == listTransactions[index]->dateTime && t.summa == listTransactions[index]->summa) {
                        t.paymentMethod = listTransactions[index]->paymentMethod;
                        break;
                    }
                }
                break;
            case 7:
                cout << "Введите новый комментарий: ";
                getline(cin, listTransactions[index]->comment);
                break;
            case 8:
                saveTransactions();
                cout << "\nИзменения сохранены!\n";
                return;
            case 9:
                cout << "\nРедактирование отменено, изменения не сохранены!\n";
                loadTransactions();
                return;
            }
        }
        cout << RESET;
    }
    // 4. УДАЛИТЬ ТРАНЗАКЦИЮ
    void deleteTransaction() {
        clearConsole();
        loadTransactions();

        if (transactions.empty()) {
            cout << B << "Нет транзакций для удаления!\n";
            return;
        }

        string Date;
        while (true) {
            cout << RED << "ДЛЯ УДАЛЕНИЯ\n" << RESET;
            cout << B << "Введите дату транзакции (ДД.ММ.ГГГГ): ";
            char choice = _getch(); // тут баг с повторным вводом первого символа
            if (choice == 27) {
                cout << endl;
                return;
            }
            getline(cin, Date);
            if (checkDateFormat(Date)) break;
            else clearConsole();
        }

        Transaction lastDeletedTransaction; // Хранение последней удаленной транзакции
        vector<Transaction*> listTransactions;

        while (true) {
            clearConsole();

            // Обновляем список транзакций
            listTransactions = searchTransByDate(Date);

            if (listTransactions.empty()) {
                cout << "Нет транзакций на эту дату!\n";
                return;
            }

            cout << "Транзакции за " << Date << ":\n";
            cout << setw(5) << left << "№"
                << setw(8) << left << "Тип"
                << setw(20) << left << "Дата и время"
                << setw(15) << left << "Пользователь"
                << setw(15) << left << "Категория"
                << setw(15) << left << "Магазин"
                << setw(15) << left << "Сумма (BYN)"
                << setw(15) << left << "Оплата"
                << setw(20) << left << "Комментарий" << endl;

            cout << string(130, '-') << endl;
            for (size_t i = 0; i < listTransactions.size(); i++) {
                cout << setw(5) << left << i + 1
                    << setw(8) << left << listTransactions[i]->type
                    << setw(20) << left << listTransactions[i]->dateTime
                    << setw(15) << left << listTransactions[i]->userName
                    << setw(15) << left << (listTransactions[i]->type == "расход" ? listTransactions[i]->category : "-")
                    << setw(15) << left << (listTransactions[i]->type == "расход" ? listTransactions[i]->storeName : "-")
                    << setw(15) << left << fixed << setprecision(2) << listTransactions[i]->summa
                    << setw(15) << left << listTransactions[i]->paymentMethod
                    << setw(20) << left << listTransactions[i]->comment << endl;
            }

            cout << "\nВыберите действие:\n";
            cout << "1. Удалить\n";
            cout << "2. Восстановить последнее удаление\n";
            cout << "3. Прекратить удаление и вернуться в меню\n";

            int action = input_check_int("Введите номер действия: ", 1, 3);
            int index;

            switch (action) {
            case 1:
                index = input_check_int("Введите номер транзакции для удаления или 0 для удаления всех: ", 0, listTransactions.size()) - 1;

                while (true) {
                    cout << "Вы уверены, что хотите удалить "
                        << (index == -1 ? "ВСЕ транзакции" : "транзакцию [" + to_string(index + 1) + "]")
                        << "? (+/-): ";
                    char confirmation;
                    cin >> confirmation;

                    if (confirmation == '+') {
                        if (index == -1) {
                            for (auto& t : listTransactions) {
                                lastDeletedTransaction = *t; // Запоминаем последнюю удаленную запись
                            }

                            transactions.erase(remove_if(transactions.begin(), transactions.end(),
                                [&](const Transaction& t) { return t.dateTime.substr(0, 10) == Date; }),
                                transactions.end());

                            cout << "\nВсе транзакции за " << Date << " удалены!\n";
                        }
                        else {
                            lastDeletedTransaction = *listTransactions[index]; // Запоминаем удаленную транзакцию

                            auto it = remove_if(transactions.begin(), transactions.end(),
                                [&](const Transaction& t) { return &t == listTransactions[index]; });
                            transactions.erase(it, transactions.end());
                        }
                        saveTransactions();
                        break;
                    }
                    else break;
                }
                break;

            case 2:
                cout << "Вы уверены, что хотите восстановить последнюю удаленную транзакцию? (+/-): ";
                char restore;
                cin >> restore;

                if (restore == '+') {
                    transactions.push_back(lastDeletedTransaction); // Восстанавливаем удаленную транзакцию
                    saveTransactions();
                    loadTransactions(); // Обновляем список
                    lastDeletedTransaction = {}; // Очищаем данные после первого восстановления
                }
                break;
            case 3: return;
            }
        }
        cout << RESET;
    }
    // 5. ПОКАЗАТЬ ВСЕ ТРАНЗАКЦИИ
    void showTransactions() {
        loadTransactions();
        clearConsole();

        if (transactions.empty()) {
            cout << "Нет транзакций!\n";
            return;
        }

        cout << setw(8) << left << "Тип"
            << setw(20) << left << "Дата и время"
            << setw(15) << left << "Пользователь"
            << setw(15) << left << "Категория"
            << setw(15) << left << "Магазин"
            << setw(15) << left << "Сумма (BYN)"
            << setw(15) << left << "Оплата"
            << setw(20) << left << "Комментарий" << endl;

        cout << string(120, '-') << endl;

        for (const auto& t : transactions) {
            string color = (t.type == "доход") ? GREEN : RED;
            cout << color << setw(8) << left << t.type
                << setw(20) << left << t.dateTime
                << setw(15) << left << t.userName
                << setw(15) << left << (t.type == "расход" ? t.category : "-")
                << setw(15) << left << (t.type == "расход" ? t.storeName : "-")
                << setw(15) << left << fixed << setprecision(2) << t.summa
                << setw(15) << left << t.paymentMethod
                << setw(20) << left << t.comment << RESET << endl;
        }
    }
    // 6. БЫСТРЫЙ ПЕРЕВОД МЕЖДУ СЧЕТАМИ
    void transferBalance() {
        userBalance.loadFromFile();
        char choice;
        while (true) {
            clearConsole();
            cout << B << BLUE << "1. Перевести с наличных на карту\n";
            cout << "2. Перевести с карты на наличные\n";
            cout << "\nВыберите направление перевода: ";
            choice = _getch();
            if (choice == 27) {
                cout << RESET << endl;
                break;
            }

            if (choice != '1' && choice != '2') {
                continue;
            }
            clearConsole();
            double amount;
            amount = input_check_double("Введите сумму для перевода: ", 0.0, 1000000000.0);

            if (choice == '1') { // С наличных на карту
                if (choice == 27) break;
                else if (userBalance.cash >= amount) {
                    userBalance.cash -= amount;
                    userBalance.card += amount;
                    userBalance.saveToFile();
                    cout << GREEN << "\nПеревод выполнен: " << amount << " BYN с наличных на карту.\n" << RESET;
                    break;
                }
                else {
                    cout << RED << "\nОшибка: недостаточно наличных средств!\n" << RESET;
                    return;
                }
            }
            else if (choice == '2') { // С карты на наличные
                if (choice == 27) break;
                else if (userBalance.card >= amount) {
                    userBalance.card -= amount;
                    userBalance.cash += amount;
                    userBalance.saveToFile();
                    cout << GREEN << "\nПеревод выполнен: " << amount << " BYN с карты в наличные.\n" << RESET;
                    break;
                }
                else {
                    cout << RED << "\nОшибка: недостаточно средств на карте!\n" << RESET;
                    return;
                }
            }
        }
    }
    // 7. ПОИСК
    void search() {
        loadTransactions();
        string searchCategory;
        vector<Transaction*> results;
        while (true) {
            clearConsole();
            cout << B << "      ПОИСК ТРАНЗАКЦИЙ\n";
            cout << "=============================\n";
            cout << "1 - Поиск по дате\n";
            cout << "2 - Поиск по категории\n";
            cout << "3 - Поиск по магазину\n";
            cout << "4 - Поиск по сумме\n";
            cout << "5 - Поиск по ключевому слову\n";
            cout << "=============================\n";
            cout << "Выберите вариант поиска: ";

            char choice = _getch();
            if (choice == 27) {
                cout << endl;
                return;
            }

            if (choice != '1' && choice != '2' && choice != '3' && choice != '4' && choice != '5') {
                continue;
            }

            clearConsole();

            if (transactions.empty()) {
                cout << B << RED << "Нет транзакций для поиска!\n" << RESET;
                return;
            }

            switch (choice) {
            case '1': // Поиск по дате
                while (true) {
                    cout << B << "Введите дату транзакции (ДД.ММ.ГГГГ): ";
                    getline(cin, searchCategory);
                    if (checkDateFormat(searchCategory)) break;
                    else clearConsole();
                }
                results = searchTransByDate(searchCategory);
                break;
            case '2': // Поиск по категории
                cout << "Введите категорию (еда, транспорт, подписки и т. д.): ";
                getline(cin, searchCategory);
                results = searchTransByCategory(searchCategory);
                break;
            case '3': // Поиск по магазину
                cout << "Введите название магазина: ";
                getline(cin, searchCategory);
                results = searchTransByStore(searchCategory);
                break;
            case '4': { // Поиск по сумме (диапазон)
                double minAmount, maxAmount;
                cout << "Введите минимальную сумму: ";
                cin >> minAmount;
                cout << "Введите максимальную сумму: ";
                cin >> maxAmount;
                cin.ignore();
                results = searchTransByAmount(minAmount, maxAmount);
                break;
            }
            case '5': // Поиск по ключевому слову в комментариях
                cout << "Введите ключевое слово: ";
                getline(cin, searchCategory);
                results = searchTransByKeyword(searchCategory);
                break;
            }
            // Вывод результатов
            if (results.empty()) { 
                cout << RED << "\nТранзакции не найдены!\n" << RESET; 
                return;
            }
            else {
                cout << B << "\n=======================================================================================================================\n";
                cout << setw(4) << left << "№"
                    << setw(18) << left << "Дата"
                    << setw(15) << left << "Пользователь"
                    << setw(8) << left << "Тип"
                    << setw(15) << left << "Сумма (BYN)"
                    << setw(15) << left << "Категория"
                    << setw(15) << left << "Магазин"
                    << setw(10) << left << "Оплата"
                    << setw(30) << left << "Комментарий" << endl;
                cout << "-----------------------------------------------------------------------------------------------------------------------\n";

                size_t index = 1;
                for (const auto& t : results) {
                    cout << setw(4) << left << index++
                        << setw(18) << left << t->dateTime
                        << setw(15) << left << t->userName
                        << setw(8) << left << t->type
                        << setw(15) << left << fixed << setprecision(2) << t->summa
                        << setw(15) << left << t->category
                        << setw(15) << left << t->storeName
                        << setw(10) << left << t->paymentMethod
                        << setw(30) << left << t->comment << endl;
                }
                cout << "=======================================================================================================================\n" << RESET;
                return;
            }
        }
    }
    // 8. ФИЛЬТРЫ
    void filter() {
        loadTransactions();

        // Копируем указатели на объекты транзакций
        vector<Transaction*> filteredTransactions;
        filteredTransactions.reserve(transactions.size()); // Улучшает производительность копирования
        for (auto& t : transactions) {
            filteredTransactions.push_back(&t);
        }

        string typeFilter, paymentFilter;
        char sortChoice, dateSortChoice, typeChoice, paymentChoice;

        while (true) {
            clearConsole();
            cout << B << "     ФИЛЬТРЫ ТРАНЗАКЦИЙ\n";
            cout << "=============================\n";
            cout << "1. Фильтр по пользователю\n";
            cout << "2. Фильтр по цене\n";
            cout << "3. Фильтр по дате\n";
            cout << "4. Фильтр по типу транзакции\n";
            cout << "5. Фильтр по способу оплаты\n";
            cout << "=============================\n";
            cout << "Выберите фильтр: ";

            char choice = _getch();
            if (choice == 27) return;

            if (choice != '1' && choice != '2' && choice != '3' && choice != '4' && choice != '5') {
                continue;
            }

            clearConsole();

            if (transactions.empty()) {
                cout << B << RED << "Нет транзакций для фильтрации!\n" << RESET;
                return;
            }

            string filterQuery;

            sort(filteredTransactions.begin(), filteredTransactions.end(), [](Transaction* a, Transaction* b) {
                int yearA = stoi(a->dateTime.substr(6, 4));
                int monthA = stoi(a->dateTime.substr(3, 2));
                int dayA = stoi(a->dateTime.substr(0, 2));
                int hourA = stoi(a->dateTime.substr(11, 2));
                int minuteA = stoi(a->dateTime.substr(14, 2));

                int yearB = stoi(b->dateTime.substr(6, 4));
                int monthB = stoi(b->dateTime.substr(3, 2));
                int dayB = stoi(b->dateTime.substr(0, 2));
                int hourB = stoi(b->dateTime.substr(11, 2));
                int minuteB = stoi(b->dateTime.substr(14, 2));

                if (yearA != yearB) return yearA > yearB;
                if (monthA != monthB) return monthA > monthB;
                if (dayA != dayB) return dayA > dayB;
                if (hourA != hourB) return hourA > hourB;
                return minuteA > minuteB;
                });
            switch (choice) {
            case '1': // 📌 Фильтр по пользователю
                cout << "Введите имя пользователя: ";
                getline(cin, filterQuery);
                filteredTransactions.erase(remove_if(filteredTransactions.begin(), filteredTransactions.end(),
                    [&filterQuery](Transaction* t) { return t->userName != filterQuery; }), filteredTransactions.end());
                break;

            case '2': // 📌 Фильтр по цене
                while (true) {
                    cout << "Выберите сортировку (1 - По возрастанию, 2 - По убыванию): ";
                    sortChoice = _getch();
                    if (sortChoice != '1' && sortChoice != '2') {
                        clearConsole();
                        continue;
                    }
                    sort(filteredTransactions.begin(), filteredTransactions.end(),
                        [sortChoice](Transaction* a, Transaction* b) { return (sortChoice == '1') ? a->summa < b->summa : a->summa > b->summa; });
                    break;
                }
                break;

            case '3': // Фильтр по дате 
                char dateSortChoice; 
                while (true) { 
                    cout << "Выберите порядок (1 - Новые, 2 - Старые): "; 
                    dateSortChoice = _getch(); 
                    if (dateSortChoice != '1' && dateSortChoice != '2') { 
                        clearConsole(); 
                        continue; 
                    }
                    // Сортировка с корректной разбивкой даты 
                    sort(filteredTransactions.begin(), filteredTransactions.end(), 
                        [dateSortChoice](Transaction* a, Transaction* b) { 
                            int yearA = stoi(a->dateTime.substr(6, 4)); 
                            int monthA = stoi(a->dateTime.substr(3, 2));
                            int dayA = stoi(a->dateTime.substr(0, 2)); 
                            int hourA = stoi(a->dateTime.substr(11, 2));
                            int minuteA = stoi(a->dateTime.substr(14, 2));
                            int yearB = stoi(b->dateTime.substr(6, 4)); 
                            int monthB = stoi(b->dateTime.substr(3, 2)); 
                            int dayB = stoi(b->dateTime.substr(0, 2)); 
                            int hourB = stoi(b->dateTime.substr(11, 2));
                            int minuteB = stoi(b->dateTime.substr(14, 2));
                    if (yearA != yearB) return (dateSortChoice == '1') ? yearA > yearB : yearA < yearB; 
                    if (monthA != monthB) return (dateSortChoice == '1') ? monthA > monthB : monthA < monthB; 
                    if (dayA != dayB) return (dateSortChoice == '1') ? dayA > dayB : dayA < dayB; 
                    if (hourA != hourB) return (dateSortChoice == '1') ? hourA > hourB : hourA < hourB; return (dateSortChoice == '1') ? minuteA > minuteB : minuteA < minuteB;
                }); break;
            } break;

            case '4': // Фильтр по типу
                while (true) {
                    cout << "Выберите тип (1 - Доход, 2 - Расход): ";
                    typeChoice = _getch();
                    if (typeChoice != '1' && typeChoice != '2') {
                        clearConsole();
                        continue;
                    }
                    string typeFilter = (typeChoice == '1') ? "доход" : "расход";
                    filteredTransactions.erase(remove_if(filteredTransactions.begin(), filteredTransactions.end(),
                        [&typeFilter](Transaction* t) { return t->type != typeFilter; }), filteredTransactions.end());
                    break;
                }
                break;

            case '5': // Фильтр по способу оплаты
                while (true) {
                    cout << "Выберите способ оплаты (1 - Наличные, 2 - Карта): ";
                    paymentChoice = _getch();
                    if (paymentChoice != '1' && paymentChoice != '2') {
                        clearConsole();
                        continue;
                    }
                    string paymentFilter = (paymentChoice == '1') ? "наличные" : "карта";
                    filteredTransactions.erase(remove_if(filteredTransactions.begin(), filteredTransactions.end(),
                        [&paymentFilter](Transaction* t) { return t->paymentMethod != paymentFilter; }), filteredTransactions.end());
                    break;
                }
                break;
            }

            // Вывод транзакций
            if (filteredTransactions.empty()) {
                cout << RED << "\nНет транзакций по заданному фильтру!\n" << RESET;
                return;
            }
            cout << B << "\n=======================================================================================================================\n";
            cout << setw(4) << left << "№"
                << setw(18) << left << "Дата"
                << setw(15) << left << "Пользователь"
                << setw(8) << left << "Тип"
                << setw(15) << left << "Сумма (BYN)"
                << setw(15) << left << "Категория"
                << setw(15) << left << "Магазин"
                << setw(10) << left << "Оплата"
                << setw(30) << left << "Комментарий" << endl;
            cout << "-----------------------------------------------------------------------------------------------------------------------\n";

            size_t index = 1;
            for (const auto& t : filteredTransactions) {
                cout << setw(4) << left << index++
                    << setw(18) << left << t->dateTime
                    << setw(15) << left << t->userName
                    << setw(8) << left << t->type
                    << setw(15) << left << fixed << setprecision(2) << t->summa
                    << setw(15) << left << t->category
                    << setw(15) << left << t->storeName
                    << setw(10) << left << t->paymentMethod
                    << setw(30) << left << t->comment << endl;
            }
            cout << "=======================================================================================================================\n" << RESET;
            return;
        }
    }
    // 9. СТАТИСТИКА
    void Statistics() {
        loadTransactions();
        clearConsole();
        userBalance.loadFromFile();

        double totalExpenses = 0, totalIncome = 0;
        double maxExpense = 0;
        string maxExpenseItem = "";
        map<string, double> categoryExpenses;
        map<string, int> storeCount;
        map<string, bool> incomeMonths; // Для подсчета месяцев с доходами

        // Анализ транзакций
        for (const auto& t : transactions) {
            string monthYear = t.dateTime.substr(3, 7); // "MM.YYYY"

            if (t.type == "доход") {
                totalIncome += t.summa;
                incomeMonths[monthYear] = true; // Запоминаем, что в этом месяце был доход
            }
            else if (t.type == "расход") {
                totalExpenses += t.summa;
                categoryExpenses[t.category] += t.summa;
                storeCount[t.storeName]++;

                // Определяем самую крупную покупку
                if (t.summa > maxExpense) {
                    maxExpense = t.summa;
                    maxExpenseItem = t.category + " (" + t.storeName + ")";
                }
            }
        }

        // Средний доход за месяц
        int activeIncomeMonths = incomeMonths.size(); // Количество месяцев с доходами
        double avgMonthlyIncome = (activeIncomeMonths > 0) ? totalIncome / activeIncomeMonths : 0.0;

        // Определение наибольшей категории расходов
        string topCategory = "";
        double maxCategoryExpense = 0;
        for (const auto& category : categoryExpenses) {
            if (category.second > maxCategoryExpense) {
                maxCategoryExpense = category.second;
                topCategory = category.first;
            }
        }

        // Определение самого популярного магазина
        string topStore = "";
        int maxStoreVisits = 0;
        for (const auto& store : storeCount) {
            if (store.second > maxStoreVisits) {
                maxStoreVisits = store.second;
                topStore = store.first;
            }
        }

        // Сравнение с предыдущими месяцами
        double prevMonthExpenses = getMonthExpenses(transactions, getNowMonth() - 1, getNowYear());
        double prevMonthIncome = getIncomeForMonth(transactions, getNowMonth() - 1, getNowYear());

        double expenseDifference = totalExpenses - prevMonthExpenses;
        double incomeDifference = totalIncome - prevMonthIncome;

        // Предупреждения о рисках
        bool budgetRisk = totalExpenses > totalIncome * 0.8;
        bool negativeBudget = totalExpenses > totalIncome;

        // Вывод статистики
        cout << B << BLUE << "               **СТАТИСТИКА ФИНАНСОВ** \n";
        cout << "=======================================================\n";
        cout << setw(28) << left << "Общая сумма доходов: " << fixed << setprecision(2) << totalIncome << " BYN\n";
        cout << "-------------------------------------------------------\n";
        cout << setw(28) << left << "Средний доход за месяц: " << fixed << setprecision(2) << avgMonthlyIncome << " BYN\n";
        cout << "-------------------------------------------------------\n";
        cout << setw(28) << left << "Общая сумма расходов: " << fixed << setprecision(2) << totalExpenses << " BYN\n";
        cout << "-------------------------------------------------------\n";
        cout << setw(28) << left << "Средний расход за месяц: " << fixed << setprecision(2) << userBalance.averageMonthExpense << " BYN\n";
        cout << "-------------------------------------------------------\n";
        cout << setw(28) << left << "Средний расход за день: " << fixed << setprecision(2) << userBalance.averageDayExpense << " BYN\n";
        cout << "-------------------------------------------------------\n";
        cout << setw(28) << left << "Самая крупная покупка: " << maxExpenseItem << " (" << fixed << setprecision(2) << maxExpense << " BYN)\n";
        cout << "-------------------------------------------------------\n";
        cout << setw(28) << left << "Самая затратная категория: " << topCategory << " (" << maxCategoryExpense << " BYN)\n";
        cout << "-------------------------------------------------------\n";
        cout << setw(28) << left << "Самый популярный магазин: " << topStore << " (транзакций: " << maxStoreVisits << ")\n";
        cout << "-------------------------------------------------------\n";

        cout << "Сравнение с предыдущим месяцем:\n";

        if (expenseDifference > 0) {
            cout << setw(9) << left << "Расходы: " << "[+] увеличились на " << fixed << setprecision(2) << expenseDifference << " BYN\n";
        }
        else {
            cout << setw(9) << left << "Расходы: " << "[-] снизились на " << fixed << setprecision(2) << abs(expenseDifference) << " BYN\n";
        }

        if (incomeDifference > 0) {
            cout << setw(9) << left << "Доходы: " << "[+] увеличились на " << fixed << setprecision(2) << incomeDifference << " BYN\n";
        }
        else {
            cout << setw(9) << left << "Доходы: " << "[-] снизились на " << fixed << setprecision(2) << abs(incomeDifference) << " BYN\n";
        }

        cout << "=======================================================\n" << RESET;

        if (budgetRisk) {
            cout << B << RED << "\n! ! ! Внимание: расходы превышают 80% от доходов!\n" << RESET;
        }
        if (negativeBudget) {
            cout << B << RED << "\n! ! ! Срочное предупреждение: бюджет отрицательный!\n" << RESET;
        }
    }
    // 0. НАСТРОЙКИ
    void setupSettings() {
        clearConsole();
        cout << "Примечание: при обновлении баланса меняется ТОЛЬКО баланс\n\n";
        cout << "      **НАСТРОЙКИ ФИНАНСОВ**\n";
        cout << "--------------------------------------\n";

        cout << "Введите количество карт: ";
        int cardCount;
        cin >> cardCount;

        double newCardAmount = 0; // Временное значение (не изменяем сразу)
        for (int i = 0; i < cardCount; i++) {
            double cardBalance;
            cout << "Введите остаток на карте " << i + 1 << ": ";
            cin >> cardBalance;
            newCardAmount += cardBalance;
        }

        cout << "Введите сумму наличных: ";
        double newCashAmount;
        cin >> newCashAmount;
        double newTotalSumma = newCashAmount + newCardAmount;

        cout << "\nВы уверены, что хотите сохранить изменения? (+/-): ";
        char confirm;
        cin >> confirm;

        if (confirm == '+') {
            userBalance.card = newCardAmount;
            userBalance.cash = newCashAmount;
            userBalance.totalSumma = newTotalSumma;
            userBalance.saveToFile();
            cout << "\nНастройки сохранены!\n";
        }
        else {
            cout << "\nИзменения отменены!\n";
        }
    }

    
    // загрузка сохраненных транзакций
    void loadTransactions() {
        transactions.clear();
        ifstream file("transactions.txt");
        if (!file) {
            cout << "Нет сохраненных транзакций!\n";
            return;
        }

        string line;
        while (getline(file, line)) {
            stringstream ss(line);
            string dateTime, userName, type, summaStr, paymentMethod, category, storeName, comment;

            getline(ss, dateTime, ',');
            getline(ss, userName, ',');
            getline(ss, type, ',');
            getline(ss, summaStr, ',');
            getline(ss, paymentMethod, ',');
            if (type == "расход") {
                getline(ss, category, ',');
                getline(ss, storeName, ',');
            }
            else {
                category = "-";
                storeName = "-";
            }

            getline(ss, comment, ',');

            transactions.emplace_back(userName, type, stod(summaStr), paymentMethod, category, storeName, comment);
            transactions.back().dateTime = dateTime;
        }
        file.close();
    }
    // Функция сохранения изменений в файл
    void saveTransactions() {
        ofstream file("transactions.txt", ios::trunc);
        if (file) {
            for (const auto& t : transactions) {
                file << t.toTXT() << endl;
            }
            file.close();
        }
        else {
            cout << "\nОшибка записи в файл!\n";
        }
    }
    // расход за месяц
    double getMonthExpenses(const vector<Transaction>& transactions, int month, int year) {
        double total = 0;
        loadTransactions();
        for (const auto& t : transactions) {
            int transMonth = stoi(t.dateTime.substr(3, 2));
            int transYear = stoi(t.dateTime.substr(6, 4));

            if (transMonth == month && transYear == year && t.type == "расход") {
                total += t.summa;
            }
        }
        return total;
    }
    // средний расход в день
    double getAverageDayExpense(const vector<Transaction>& transactions) {
        loadTransactions();
        double total = getMonthExpenses(transactions, getNowMonth(), getNowYear());
        int nowDay = getMaxDay(transactions);
        return (nowDay > 0) ? (total / nowDay) : 0.0;
    }
    // средний расход в месяц
    double getAverageMonthExpense(const vector<Transaction>& transactions) {
        loadTransactions();
        if (transactions.empty()) return 0.0;
        double total = 0;
        int minMonth = 12, minYear = 3000, maxMonth = 1, maxYear = 1900;

        for (const auto& t : transactions) {
            if (t.type == "расход") {
                int transMonth = stoi(t.dateTime.substr(3, 2));
                int transYear = stoi(t.dateTime.substr(6, 4));

                total += t.summa;

                // Определяем минимальный и максимальный месяц
                if (transYear < minYear || (transYear == minYear && transMonth < minMonth)) {
                    minYear = transYear;
                    minMonth = transMonth;
                }
                if (transYear > maxYear || (transYear == maxYear && transMonth > maxMonth)) {
                    maxYear = transYear;
                    maxMonth = transMonth;
                }
            }
        }
        int totalMonths = (maxYear - minYear) * 12 + (maxMonth - minMonth) + 1;
        return (totalMonths > 0) ? (total / totalMonths) : 0.0; 
    }
    // получение формальной даты из транзакций
    int getMaxDay(const vector<Transaction>& transactions) {
        int currentDay = getNowDay(); // Получаем текущую дату
        int maxDay = currentDay;

        // Загружаем транзакции и проверяем последнюю дату
        for (const auto& t : transactions) {
            int transDay = stoi(t.dateTime.substr(0, 2));
            int transMonth = stoi(t.dateTime.substr(3, 2));
            int transYear = stoi(t.dateTime.substr(6, 4));

            // Проверяем, если транзакция в текущем месяце и году
            if (transMonth == getNowMonth() && transYear == getNowYear()) {
                maxDay = max(maxDay, transDay); // 📌 Берем максимальный день
            }
        }
        return maxDay;
    }
    // получение текущего дня, месяца, года
    int getNowDay() {
        time_t now = time(0);
        tm localTime;
        localtime_s(&localTime, &now);
        return localTime.tm_mday;
    }
    int getNowMonth() {
        time_t now = time(0);
        tm localTime;
        localtime_s(&localTime, &now);
        return localTime.tm_mon + 1;
    }
    int getNowYear() {
        time_t now = time(0);
        tm localTime;
        localtime_s(&localTime, &now);
        return localTime.tm_year + 1900;
    }
    // поиск транзакций по дате
    vector<Transaction*> searchTransByDate(const string& targetDate) {
        vector<Transaction*> filteredTransactions;
        for (auto& t : transactions) {
            if (t.dateTime.substr(0, 10) == targetDate) {
                filteredTransactions.push_back(&t);
            }
        }
        return filteredTransactions;
    }
    // поиск транзакций по категориям
    vector<Transaction*> searchTransByCategory(const string& targetCategory) {
        vector<Transaction*> filteredTransactions;
        for (auto& t : transactions) {
            if (t.category == targetCategory) {
                filteredTransactions.push_back(&t);
            }
        }
        return filteredTransactions;
    }
    // поиск транзакций по магазину
    vector<Transaction*> searchTransByStore(const string& targetStore) {
        vector<Transaction*> filteredTransactions;
        for (auto& t : transactions) {
            if (t.storeName == targetStore) {
                filteredTransactions.push_back(&t);
            }
        }
        return filteredTransactions;
    }
    // поиск транзакций по сумме (диапазон)
    vector<Transaction*> searchTransByAmount(double minAmount, double maxAmount) {
        vector<Transaction*> filteredTransactions;
        for (auto& t : transactions) {
            if (t.summa >= minAmount && t.summa <= maxAmount) {
                filteredTransactions.push_back(&t);
            }
        }
        return filteredTransactions;
    }
    // поиск по ключевому слову в комментариях
    vector<Transaction*> searchTransByKeyword(const string& keyword) {
        vector<Transaction*> filteredTransactions;
        for (auto& t : transactions) {
            if (t.comment.find(keyword) != string::npos) { // Проверяем, содержит ли комментарий ключевое слово
                filteredTransactions.push_back(&t);
            }
        }
        return filteredTransactions;
    }

    // доход за месяц
    double getIncomeForMonth(const vector<Transaction>& transactions, int month, int year) {
        loadTransactions();
        double totalIncome = 0;
        for (const auto& t : transactions) {
            int transMonth = stoi(t.dateTime.substr(3, 2));
            int transYear = stoi(t.dateTime.substr(6, 4));

            if (transMonth == month && transYear == year && t.type == "доход") {
                totalIncome += t.summa;
            }
        }
        return totalIncome;
    }
    
    void showMenu() {
        cout << B << YELLOW << "Esc - Выход\n\n";
        cout << "======= Главное меню =======\n";
        cout << "1. Баланс\n";                          // +
        cout << "2. Добавить транзакцию\n";             // +
        cout << "3. Редактировать транзакцию\n";        // +
        cout << "4. Удалить транзакцию\n";              // +
        cout << "5. Показать все транзакции\n";         // +
        cout << "6. Быстрый перевод между счетами\n";   // +
        cout << "7. Поиск\n";                           // +
        cout << "8. Фильтры\n";                         // +
        cout << "9. Статистика\n";                      // +
        cout << "0. Настройки\n";                       // +
        cout << "Выберите действие:" << RESET;
    }
};

// Главная функция
static void Menu(MoneyManager& money_manager) {
    while (true) {
        clearConsole();
        money_manager.showMenu();

        char choice = _getch();
        if (choice == 27) break; // Esc для выхода

        if (choice != '1' && choice != '2' && choice != '3' && choice != '4'
            && choice != '5' && choice != '6' && choice != '7' && choice != '8' 
            && choice != '9' && choice != '0') {
            continue;
        }

        clearConsole();
        switch (choice) {
        case '1': { money_manager.Balance(); break; }
        case '2': { money_manager.addTransaction(); break;    }
        case '3': { money_manager.redactTransaction(); break; }
        case '4': { money_manager.deleteTransaction(); break; }
        case '5': { money_manager.showTransactions(); break;  }
        case '6': { money_manager.transferBalance(); break; }
        case '7': { money_manager.search(); break; }
        case '8': { money_manager.filter(); break; }
        case '9': { money_manager.Statistics(); break; }
        case '0': { money_manager.setupSettings(); break; }
        }

        cout << B << "\nНажмите Esc, чтобы вернуться в меню...";
        while (_getch() != 27);
    }
}

int main() {
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    setlocale(LC_ALL, "RU");
    SetConsoleTitle(L"Учёт домашних финансов");

    HWND consoleWindow = GetConsoleWindow();
    RECT screenRect;
    GetWindowRect(GetDesktopWindow(), &screenRect);
    int screenWidth = screenRect.right;
    int screenHeight = screenRect.bottom;
    int consoleWidth = 1500; // Ширина
    int consoleHeight = 600; // Высота
    int x = (screenWidth - consoleWidth) / 2;
    int y = (screenHeight - consoleHeight) / 2;
    MoveWindow(consoleWindow, x, y, consoleWidth, consoleHeight, TRUE);

    MoneyManager money_manager;
    showWelcomeScreen();
    Menu(money_manager);
    return 0;
}
