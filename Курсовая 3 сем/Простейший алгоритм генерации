// Program.cs
// Подключаем новую библиотеку для работы с изображениями
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Drawing.Processing;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Program
{
    public static void Main()
    {
        // Текст для кодирования. Для версии 1-L лимит ~17 символов.
        string textToEncode = "HELLO QR";

        // Генерируем матрицу QR-кода
        bool[,] qrMatrix = QrCodeGenerator.Generate(textToEncode);

        // Сохраняем как PNG с помощью ImageSharp
        SaveQrCodeAsPng(qrMatrix, 20, "my_working_qrcode.png");

        Console.WriteLine("QR-код успешно сгенерирован и сохранен.");
    }

    // --- НОВЫЙ МЕТОД СОХРАНЕНИЯ ИЗОБРАЖЕНИЯ ---
    private static void SaveQrCodeAsPng(bool[,] matrix, int moduleSize, string filePath)
    {
        int quietZone = 4; // Стандартная белая рамка
        int matrixSize = matrix.GetLength(0);
        int imageSize = (matrixSize + quietZone * 2) * moduleSize;

        using (var image = new Image<Rgba32>(imageSize, imageSize))
        {
            image.Mutate(ctx => ctx.Fill(Color.White)); // Белый фон

            for (int y = 0; y < matrixSize; y++)
            {
                for (int x = 0; x < matrixSize; x++)
                {
                    if (matrix[y, x]) // Если модуль черный
                    {
                        var rect = new Rectangle((x + quietZone) * moduleSize, (y + quietZone) * moduleSize, moduleSize, moduleSize);
                        image.Mutate(ctx => ctx.Fill(Color.Black, rect));
                    }
                }
            }
            image.SaveAsPng(filePath);
        }
    }
}

public static class QrCodeGenerator
{
    private static byte[] CreateDataCodewords(string text)
    {
        const int totalDataCodewords = 19;
        byte[] textBytes = Encoding.GetEncoding("ISO-8859-1").GetBytes(text);
        if (textBytes.Length > 17) throw new Exception("Текст слишком длинный для QR v1-L");

        var bitStream = new List<bool>();
        bitStream.AddRange(new[] { false, true, false, false }); // Режим Byte
        string lengthBinary = Convert.ToString(textBytes.Length, 2).PadLeft(8, '0');
        foreach (char c in lengthBinary) bitStream.Add(c == '1');

        foreach (byte b in textBytes)
        {
            string byteBinary = Convert.ToString(b, 2).PadLeft(8, '0');
            foreach (char c in byteBinary) bitStream.Add(c == '1');
        }

        for (int i = 0; i < 4 && bitStream.Count < totalDataCodewords * 8; i++) bitStream.Add(false);
        while (bitStream.Count % 8 != 0) bitStream.Add(false);

        byte[] paddingBytes = { 0b11101100, 0b00010001 };
        int paddingIndex = 0;
        while (bitStream.Count < totalDataCodewords * 8)
        {
            string padBinary = Convert.ToString(paddingBytes[paddingIndex], 2).PadLeft(8, '0');
            foreach (char c in padBinary) bitStream.Add(c == '1');
            paddingIndex = (paddingIndex + 1) % 2;
        }

        var codewords = new byte[totalDataCodewords];
        for (int i = 0; i < totalDataCodewords; i++)
        {
            for (int j = 0; j < 8; j++)
            {
                if (bitStream[i * 8 + j])
                {
                    codewords[i] |= (byte)(1 << (7 - j));
                }
            }
        }
        return codewords;
    }

    private static byte[] CreateErrorCorrectionCodewords(byte[] dataCodewords)
    {
        const int numErrorCodewords = 7;
        int[] generatorPolynomial = { 87, 229, 146, 149, 238, 102, 21 };
        var message = new int[dataCodewords.Length + numErrorCodewords];
        Array.Copy(dataCodewords, message, dataCodewords.Length);

        for (int i = 0; i < dataCodewords.Length; i++)
        {
            int alpha = message[i];
            if (alpha != 0)
            {
                int logAlpha = GfLog[alpha];
                for (int j = 0; j < generatorPolynomial.Length; j++)
                {
                    int logSum = (logAlpha + generatorPolynomial[j]) % 255;
                    int term = GfExp[logSum];
                    message[i + j + 1] ^= term;
                }
            }
        }

        var errorCodewords = new byte[numErrorCodewords];
        for (int i = 0; i < numErrorCodewords; i++)
        {
            errorCodewords[i] = (byte)message[dataCodewords.Length + i];
        }
        return errorCodewords;
    }

    public static bool[,] Generate(string text)
    {
        const int size = 21;
        const int maskPattern = 0;

        byte[] dataCodewords = CreateDataCodewords(text);
        byte[] errorCodewords = CreateErrorCorrectionCodewords(dataCodewords);
        byte[] finalMessage = dataCodewords.Concat(errorCodewords).ToArray();

        var matrix = new bool[size, size];
        var reserved = new bool[size, size];

        DrawFinderPatterns(matrix, reserved);
        DrawTimingPatterns(matrix, reserved);
        DrawDarkModule(matrix, reserved);
        DrawFormatInformation(matrix, reserved, maskPattern); // --- КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ ---
        DrawData(matrix, reserved, finalMessage);
        ApplyMask(matrix, reserved, maskPattern);

        return matrix;
    }

    #region Отрисовка служебных элементов
    private static void DrawFinderPatterns(bool[,] matrix, bool[,] reserved)
    {
        int size = matrix.GetLength(0);
        int[] positions = { 0, size - 7 };
        foreach (int y in positions)
        {
            foreach (int x in positions)
            {
                if (!((x == size - 7 && y == size - 7)))
                {
                    for (int row = -1; row <= 7; row++)
                    {
                        for (int col = -1; col <= 7; col++)
                        {
                            if (y + row >= 0 && y + row < size && x + col >= 0 && x + col < size)
                            {
                                reserved[y + row, x + col] = true;
                            }
                        }
                    }

                    for (int row = 0; row < 7; row++)
                    {
                        for (int col = 0; col < 7; col++)
                        {
                            matrix[y + row, x + col] = (row == 0 || row == 6 || col == 0 || col == 6 || (row >= 2 && row <= 4 && col >= 2 && col <= 4));
                        }
                    }
                }
            }
        }
    }

    private static void DrawTimingPatterns(bool[,] matrix, bool[,] reserved)
    {
        for (int i = 8; i < 13; i++)
        {
            bool isBlack = i % 2 == 0;
            if (!reserved[6, i]) { matrix[6, i] = isBlack; reserved[6, i] = true; }
            if (!reserved[i, 6]) { matrix[i, 6] = isBlack; reserved[i, 6] = true; }
        }
    }

    private static void DrawDarkModule(bool[,] matrix, bool[,] reserved)
    {
        matrix[13, 8] = true;
        reserved[13, 8] = true;
    }

    // --- ПОЛНОСТЬЮ ПЕРЕРАБОТАННЫЙ МЕТОД ---
    private static void DrawFormatInformation(bool[,] matrix, bool[,] reserved, int mask)
    {
        int data = (0b01 << 3) | mask; // Level L = 01
        int bch = data << 10;
        int generator = 0b10101110111;
        while (Convert.ToString(bch, 2).Length > 10)
        {
            int shift = Convert.ToString(bch, 2).Length - 11;
            bch ^= (generator << shift);
        }
        int finalFormat = ((data << 10) | bch) ^ 0b101010000010010;

        // Точные координаты для 15 бит информации
        int[,] positions = {
            {8,0}, {8,1}, {8,2}, {8,3}, {8,4}, {8,5}, {8,7}, {8,8}, {7,8}, {5,8}, {4,8}, {3,8}, {2,8}, {1,8}, {0,8}
        };

        for (int i = 0; i < 15; i++)
        {
            bool bit = ((finalFormat >> i) & 1) == 1;
            // Размещаем вокруг верхнего левого узора
            matrix[positions[i, 1], positions[i, 0]] = bit;
            reserved[positions[i, 1], positions[i, 0]] = true;

            // Размещаем зеркально в других местах
            if (i < 8) { matrix[8, 20 - i] = bit; reserved[8, 20 - i] = true; }
            if (i < 7) { matrix[20 - i, 8] = bit; reserved[20 - i, 8] = true; }
        }
    }

    private static void DrawData(bool[,] matrix, bool[,] reserved, byte[] data)
    {
        int size = matrix.GetLength(0);
        int bitIndex = 0;
        int direction = -1;
        int y = size - 1;

        for (int x = size - 1; x >= 1; x -= 2)
        {
            if (x == 6) x--;
            for (int i = 0; i < size; i++)
            {
                for (int col = 0; col < 2; col++)
                {
                    int currentX = x - col;
                    if (!reserved[y, currentX])
                    {
                        if (bitIndex < data.Length * 8)
                        {
                            matrix[y, currentX] = ((data[bitIndex / 8] >> (7 - (bitIndex % 8))) & 1) == 1;
                        }
                        else
                        {
                            matrix[y, currentX] = false;
                        }
                        bitIndex++;
                    }
                }
                y += direction;
            }
            direction *= -1;
            y += direction;
        }
    }

    private static void ApplyMask(bool[,] matrix, bool[,] reserved, int pattern)
    {
        for (int y = 0; y < matrix.GetLength(0); y++)
        {
            for (int x = 0; x < matrix.GetLength(1); x++)
            {
                if (!reserved[y, x] && ((x + y) % 2 == 0))
                {
                    matrix[y, x] = !matrix[y, x];
                }
            }
        }
    }
    #endregion

    #region Таблицы для математики в полях Галуа GF(256)
    private static readonly int[] GfExp = new int[512];
    private static readonly int[] GfLog = new int[256];
    static QrCodeGenerator()
    {
        int x = 1;
        for (int i = 0; i < 255; i++)
        {
            GfExp[i] = x;
            GfLog[x] = i;
            x <<= 1;
            if (x > 255) x ^= 0x11D;
        }
        for (int i = 255; i < 512; i++) GfExp[i] = GfExp[i - 255];
    }
    #endregion
}
